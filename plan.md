База данных - PostgreSQL
localhost:1234
Hostname: postgres
Пользователь: postgres
Пароль: postgres

В отдельный конфиг файл вынести:
- параметры для подключения к БД
- время для повтора цикла
- количество параллельных воркеров

Таблица groups:
- id
- description
- is_active

Таблица networks:
- id
- group_id
- network_address
- gateway_ip
- alternative_ip
- description
- created_at
- updated_at
- is_active

Таблица ping_history:
- id
- group_id
- network_id
- ipaddress
- state
- changed_at

1. Программа запрашивает из БД все активные группы (is_active=true)
2. Запрашиваем подсети которые принадлежат этим активным группам.
3. Собираем из подсетей alternative_ip и формируем список уникальных альтернативных ip-адресов. Опрашиваем отдельным параллельным воркером командой «fping -c 2 -t 500 -a 192.168.1.1 192.168.1.2 192.168.1.3 и тд»
4. Каждую подсеть опрашиваем отдельным параллельным воркером командой «fping -c 2 -t 500 -a -g 192.168.1.0/24».
5. Примеры ответов от устройств при опросе утилитой fping:
	- ICMP Host Unreachable from 10.42.3.130 for ICMP Echo sent to 10.10.0.94
	- 10.10.0.94  : xmt/rcv/%loss = 2/0/100%
	- 10.10.0.245 : xmt/rcv/%loss = 2/2/0%, min/avg/max = 6.35/6.74/7.14
	- 10.10.0.250 : xmt/rcv/%loss = 2/1/50%, min/avg/max = 3.85/3.89/3.93
6. Парсим полученные строки по наличию «min/avg/max». Если это выражение имеется в строке, значит устройство живое, иначе - нет.
7. Формируем json структуру, где будут записаны опрошенные подсети (ip_адреса по возрастанию) и альтернативные ip-адреса. Если альтернативный ip-адрес был получен от разных подсетей, то в случае с уникальным списком он пингуется один раз, и результат записывается для всех подсетей к которым он имеет отношения:
```json
{
  "devices": [
    {
      "ip": "10.10.0.1",
      "alive": true,
      "description": "Город-1",
      "source_subnet": "10.10.0.0/24",
      "timestamp": "2025-11-25 22:31:31",
      "group_id": 42,
      "network_id": 101,
      "recurrences": 3
    },
    {
      "ip": "10.10.0.2",
      "alive": false,
      "description": "Город-1",
      "source_subnet": "10.10.0.0/24",
      "timestamp": "2025-11-25 22:31:31",
      "group_id": 4,
      "network_id": 101,
      "recurrences": 3
    },
    {
      "ip": "10.11.0.2",
      "alive": false,
      "description": "Город-2",
      "source_subnet": "10.11.0.0/24",
      "timestamp": "2025-11-25 22:31:31",
      "group_id": 4,
      "network_id": 56,
      "recurrences": 3
    },
    {…} ,
    {
      "ip": "10.40.50.2",
      "alive": true,
      "description": "Город-2",
      "source_subnet": "10.11.0.0/24",
      "timestamp": "2025-11-25 22:31:31",
      "group_id": 4,
      "network_id": 101,
      "recurrences": 3
    },
    {
      "ip": "10.40.50.2",
      "alive": true,
      "description": "Город-1",
      "source_subnet": "10.11.0.0/24",
      "timestamp": "2025-11-25 22:31:31",
      "group_id": 4,
      "network_id": 56,
      "recurrences": 3
    }
  ],
  “duration”: 5.63 s,
  "datetime": "2025-11-25 22:31:31"
}
```
8. Проверяем, существует ли файл last_ping.json . Если нет - создаем, и записываем туда данные которые мы сформировали ранее в json структуре со значением поля "recurrences" равным 1. ВАЖНО: При первом опросе (когда файл last_ping.json не существует), в базу данных НЕ записываем результаты опроса, а только формируем файл last_ping.json.
9. Если файл существует - проверяем каждый ip адрес на совпадение состояний устройств. Если состояния совпадают - увеличиваем значение поля "recurrences" на +1. Если состояния не совпадают или если устройства с таким ip-адресом еще нет в last_ping.json - устанавливаем значение "recurrences" равным 1, перезаписываем актуальное время опроса и состояние, а так же записываем в БД в таблицу ping_history данные об изменении состояния устройства (group_id, network_id, ipaddress, state, changed_at).
10. Скрипт должен запускаться каждые 30 секунд.

